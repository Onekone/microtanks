<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>tile_placer = 0;

cooldown = 0;

old_mouse_x = mouse_x;
old_mouse_y = mouse_y;

_x = 0;
_y = 0;

player = 0;

palette_shift = 0;
palette_angle = 0;

selected = 0;
    
tile_list_size = 0; 
    tile_x[tile_list_size] = 0; tile_y[tile_list_size] = 0;  tile_name[tile_list_size] = "ERASE";  tile_list[tile_list_size++] = tile_none;
    tile_x[tile_list_size] = 16; tile_y[tile_list_size] = 0; tile_name[tile_list_size] = "BRICK";   tile_list[tile_list_size++] = tile_brick;
    tile_x[tile_list_size] = 32; tile_y[tile_list_size] = 0; tile_name[tile_list_size] = "STEEL";   tile_list[tile_list_size++] = tile_steel;
    tile_x[tile_list_size] = 0; tile_y[tile_list_size] = 8;  tile_name[tile_list_size] = "JUNGLE";  tile_list[tile_list_size++] = tile_jungle;
    tile_x[tile_list_size] = 16; tile_y[tile_list_size] = 8; tile_name[tile_list_size] = "WATER";   tile_list[tile_list_size++] = tile_water;
    tile_x[tile_list_size] = 8; tile_y[tile_list_size] = 8;  tile_name[tile_list_size] = "SNOW";  tile_list[tile_list_size++] = tile_snow;
    tile_x[tile_list_size] = 32; tile_y[tile_list_size] = 8; tile_name[tile_list_size] = "SAND";   tile_list[tile_list_size++] = tile_sand;    
    tile_x[tile_list_size] = 8; tile_y[tile_list_size] = 16; tile_name[tile_list_size] = "SWAMP";   tile_list[tile_list_size++] = tile_swamp;        
    tile_x[tile_list_size] = 24; tile_y[tile_list_size] = 24;tile_name[tile_list_size] = "ENEMY START";    tile_list[tile_list_size++] = tile_enemyspawner;
    tile_x[tile_list_size] = 8; tile_y[tile_list_size] = 24; tile_name[tile_list_size] = "BASE HQ";   tile_list[tile_list_size++] = tile_eagle;    
    tile_x[tile_list_size] = 24; tile_y[tile_list_size] = 32;tile_name[tile_list_size] = "PLAYER START";    tile_list[tile_list_size++] = -1; // player spawner
    
    eagle = 231;

for(i=0;i&lt;10;i++) {
    select[i] = 0;
    select_pressed[i] = -1;
    select_released[i] = -1;
    }

 tank_selected_a = 0;
 tank_selected_b = 0;
    
 round_number = 0;
 
for(i=0;i&lt;25;i++) {
    file = working_directory+"mappacks/"+global.mapPack+"/level_"+string(i+1)+".mtl";
    level_exists[i] = file_exists(file);
}
     
global.paused = 2;
with obj_controller 
    visible = false;
    
mode = mode_drawer;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alarm[0]=1;

instance_destroy(obj_tank,0);
instance_destroy(obj_projectile,0);
instance_destroy(obj_powerup,0);
instance_destroy(obj_particle,0);
instance_destroy(obj_tankappear,0);
instance_destroy(obj_textpopup,0);
instance_destroy(obj_solidobject,0);
instance_destroy(obj_gameoverlabel,0);

for(var i=0;i&lt;4;i++) {
    global.Score[i] = 0;
    global.Lives[i] = 3;
    global.PowerUp[i] = 0;
    global.ExtraTankScore[i] = 20000;                                            
    
    for(var j=0;j&lt;4;j++) {
     global.TotalKills[i,j]=0;
     global.RoundKills[i,j]=0; 
     }
}     
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>file = working_directory+"mappacks/"+global.mapPack+"/level_construction.mtl";
        
if file_exists(file)
    {
        k = buffer_load(file);
        levelLoadFromBuffer(k);
        buffer_delete(k);
        
        instance_destroy(obj_tankspawner);
        instance_destroy(obj_defensetarget);
    };
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//with obj_controller visible = 0;
global.RoundStatus = round_editor;

selected = lerp(selected,tile_placer,0.25);

mouse_moved = !(old_mouse_x == mouse_x and old_mouse_y == mouse_y) || mouse_check_button_pressed(mb_left) || mouse_check_button_released(mb_left);
old_mouse_x = mouse_x;
old_mouse_y = mouse_y;

switch mode { 

case mode_drawer:
    if mouse_moved {
        _x = mouse_x div tileSize;
        _y = mouse_y div tileSize;
    }
    
    if mouse_check_button_pressed(mb_left) {
        if mouse_x &gt;0 and mouse_x&lt;tileSize*boardSize and mouse_y&gt;0 and mouse_y&lt;tileSize*boardSize+8
        switch tile_list[tile_placer] {
            case -1: 
                global.player_spawner[player] = mouse_x div 8 + mouse_y div 8 * 16;
                player = (player+1) mod 4; 
            break;
        }
        if point_distance(-8,64,mouse_x,mouse_y)&lt;=8 {
            mode = mode_palette;
            break;
            }
        else if point_distance(160-24,64,mouse_x,mouse_y)&lt;=8 {
            mode = mode_settings;
            break;
            }                 
    }
    if mouse_check_button(mb_left) {
        if mouse_x &gt;0 and mouse_x&lt;tileSize*boardSize and mouse_y&gt;0 and mouse_y&lt;tileSize*boardSize+8
        switch tile_list[tile_placer] {
            case -1:
            break;
            default: tile_replace(mouse_x div 8,mouse_y div 8,tile_list[tile_placer]); 
        }
    }
    if mouse_check_button(mb_right) {
        if mouse_x &gt;0 and mouse_x&lt;tileSize*boardSize and mouse_y&gt;0 and mouse_y&lt;tileSize*boardSize+8
        switch tile_list[tile_placer] {
            case -2: ;
            default: tile_replace(mouse_x div 8,mouse_y div 8,tile_none);
        }
    }
    if mouse_wheel_up() {
        tile_placer = (tile_list_size+tile_placer - 1) mod tile_list_size;
    }
    if mouse_wheel_down() {
        tile_placer = (tile_placer + 1) mod tile_list_size;
    }
    
    _x = clamp(_x,0,boardSize-1);
    _y = clamp(_y,0,boardSize-1);
    
    palette_shift = lerp(palette_shift,0,0.25);
    
    break;
    
case mode_palette:

    palette_shift = lerp(palette_shift,1,0.25);
    var tls = 180/(tile_list_size)
    
    palette_angle = angle_difference(90,point_direction(-8,64,mouse_x,mouse_y));
        if palette_angle&lt;0 palette_angle+=360;
    
    tile_placer = floor(floor( palette_angle ) / tls);
    tile_placer = clamp(tile_placer,0,tile_list_size-1);

    if mouse_check_button_released(mb_left) {
        mode = mode_drawer;
    }
    
    break;
    
case mode_settings:

        chooser = -1;
        action = -1;

        if mouse_moved {
            if mouse_x &gt;= 8 and mouse_x &lt;= 90 and mouse_y &gt;= 0 and mouse_y &lt;= 8 { select[mode] = 0; chooser = select[mode];}
            else if mouse_x &gt;= -8 and mouse_x &lt;= 90 and mouse_y &gt;= 28 and mouse_y &lt;= 46 {
                select[mode] = 1;
                tank_selected_a = ((mouse_x+8) div 10)+((mouse_y-28) div 10)*10;
                }
        
            else if mouse_x &gt;= 8 and mouse_x &lt; 90 and mouse_y &gt;= 56 and mouse_y &lt; 56+8        { select[mode] = 2; chooser = select[mode];}
            else if mouse_x &gt;= 8 and mouse_x &lt; 90 and mouse_y &gt;= 56+16 and mouse_y &lt; 56+16+8  { select[mode] = 3; chooser = select[mode];}
            else if mouse_x &gt;= 8 and mouse_x &lt; 90 and mouse_y &gt;= 56+32 and mouse_y &lt; 56+32+8  { select[mode] = 4; chooser = select[mode];}
            else if mouse_x &gt;= 8 and mouse_x &lt; 90 and mouse_y &gt;= 56+48 and mouse_y &lt; 56+48+8  { select[mode] = 5; chooser = select[mode];}
            else if mouse_x &gt;= 8 and mouse_x &lt; 90 and mouse_y &gt;= 56+64 and mouse_y &lt; 56+64+8  { select[mode] = 6; chooser = select[mode];}       
        }
        
       if mouse_check_button_pressed(mb_left) {
        if mouse_x &gt;= -8 and mouse_x &lt; 90 and mouse_y &gt;= 28 and mouse_y &lt; 46 {
            global.tankSet[| tank_selected_a ] = tank_selected_b; }
        else if mouse_x &gt;= 97 and mouse_x &lt; 137 and mouse_y &gt;= 28 and mouse_y &lt; 46 {
            select[mode] = 1;
            tank_selected_b = ((mouse_x-97) div 10)*2+((mouse_y-28) div 10);
            }            
        else if point_distance(160-24,view_yview+72,mouse_x,mouse_y)&lt;=8 {
            mode = mode_drawer;
            break;
            }
        
        select_pressed[mode] = chooser;
        }
        
        if mouse_check_button_released(mb_left) {
            if chooser == select_pressed[mode] and chooser&gt;=0 {
                action = chooser;
            }
            chooser = -1; select_pressed[mode] = -1;
        }
        
        switch (action) {
                case 0: mode = mode_selectlevel;
                
                for(i=0;i&lt;25;i++) {
                    file = working_directory+"mappacks/"+global.mapPack+"/level_"+string(i+1)+".mtl";
                    level_exists[i] = file_exists(file);
                }
                 
                 break;
                case 2: mode = mode_confirmsave; break;
                case 3: mode = trif(level_exists[global.Round],mode_confirmload,mode_settings); break;
                case 4:
                file = working_directory+"mappacks/"+global.mapPack+"/level_construction.mtl";
                k = levelSaveIntoBuffer();
                buffer_save(k,file);
                buffer_delete(k);
                
                instance_destroy(id);
                p = instance_create(0,0,obj_levelloader); p.roundVal = 'construction'; p.roundText = 'CONSTRUCTION LEVEL';
                break; 
                
                break;
                
                case 5: mode = mode_drawer; break;
                case 6: 
                
                k = levelSaveIntoBuffer();
                buffer_save(k,file);
                buffer_delete(k);
    
                instance_destroy(id);
                p = instance_create(0,0,obj_mainmenu); p.shift = 0; break;
                }   
    break;

case mode_selectlevel: 

        chooser = -1; action = -1;

    if mouse_moved
    if mouse_x &gt;= 0 and mouse_x &lt;= 24*5 and mouse_y &gt;= 32 and mouse_y &lt; 32+5*16 {
        select[mode] = mouse_x div 24 * 5 + (mouse_y-32) div 16 + 1;
        chooser = select[mode];
       }
    if mouse_check_button_pressed(mb_left) { select_pressed[mode] = select[mode]; }
    if mouse_check_button_released(mb_left) {
        if select_pressed[mode] == chooser action = chooser;         
        select_pressed[mode] = -1; chooser = -1;}
    
    switch action {
        case -1: {/*do nothing*/}; break;
        case 0: ; break;
        default: global.Round = select[mode]-1; mode = mode_settings;
    }
          
    break;
case mode_confirmsave:
    if mouse_moved {
            if mouse_x &gt;= 8 and mouse_x &lt; 56   and mouse_y &gt;= 56 and mouse_y &lt; 72       { select[mode] = 0; chooser = select[mode];}
       else if mouse_x &gt;= 64 and mouse_x &lt; 112 and mouse_y &gt;= 56 and mouse_y &lt; 72       { select[mode] = 1; chooser = select[mode];}
   }
         if mouse_check_button_pressed(mb_left) { select_pressed[mode] = select[mode]; }
    else if mouse_check_button_released(mb_left) {
        if select_pressed[mode] == chooser action = chooser;         
        select_pressed[mode] = -1; chooser = -1;}

       switch action {
        case 0: 
        
        file = working_directory+"mappacks/"+global.mapPack+"/level_"+string(global.Round+1)+".mtl";        
        
        k = levelSaveIntoBuffer();
        buffer_save(k,file);
        buffer_delete(k);
        
        audio_play_sound(snd_extralife,0,0);
        
        mode = mode_settings; break;
        case 1: mode = mode_settings; break;        
        default: ;
    }
    break;  
      
case mode_confirmload:
    if mouse_moved {
        if mouse_x &gt;= 8 and mouse_x &lt; 56   and mouse_y &gt;= 56 and mouse_y &lt; 72       { select[mode] = 0; chooser = select[mode];}
   else if mouse_x &gt;= 64 and mouse_x &lt; 112 and mouse_y &gt;= 56 and mouse_y &lt; 72       { select[mode] = 1; chooser = select[mode];}
   }
         if mouse_check_button_pressed(mb_left) { select_pressed[mode] = select[mode]; }
    else if mouse_check_button_released(mb_left) {
        if select_pressed[mode] == chooser action = chooser;         
        select_pressed[mode] = -1; chooser = -1;}

       switch action {
       
        case 0:
        
        file = working_directory+"mappacks/"+global.mapPack+"/level_"+string(global.Round+1)+".mtl";        
        if file_exists(file)
            {
                k = buffer_load(file);
                levelLoadFromBuffer(k);
                buffer_delete(k);
                
                instance_destroy(obj_tankspawner);
                instance_destroy(obj_defensetarget);
                audio_play_sound(snd_pause,0,0);                
            };

          mode = mode_settings; break;
        case 1: mode = mode_settings; break;        
        default: ;
    }
    break;    
default: mode = mode_drawer;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>    
   draw_set_halign(fa_left)draw_set_valign(fa_top)draw_set_font(global.fontNormal)
    _tx = 0;
    _ty = 0;
    
    switch tile_list[tile_placer] {
        case tile_none:                           break;   
        case tile_brokenbrick:  _tx = 8; _ty = 0; break;
        case tile_brick:        _tx = 16; _ty = 0; break;
        case tile_brokensteel:  _tx = 24; _ty = 0; break;
        case tile_steel:        _tx = 32; _ty = 0;break;
        case tile_jungle:       _tx = 0; _ty = 8;break;
        case tile_snow:         _tx = 8; _ty = 8;break;
        case tile_water:        _tx = 16; _ty = 8;break;
        case tile_sand:         _tx = 32; _ty = 8;break;
        case tile_swamp:        _tx = 8; _ty = 16;break;
        case tile_enemyspawner: _tx = 24; _ty = 24; break;    
        case -1:                _tx = 24; _ty = 32; draw_text_colour(mouse_x+8,mouse_y,player+1,p_white,p_white,p_white,p_white,1); break;    
        case tile_eagle:        _tx = 8; _ty = 24;break;  
            default: // welp shit;
    }
    
if mode = mode_drawer { 

    draw_background_part(background2,32,24,8,8,132,60)
    
    draw_text_colour(-8,-8,string_format(_x,2,0)+" "+string_format(_y,2,0)+" "+string_format(_x+_y*16,2,0),p_white,p_white,p_white,p_white,1)
    
    for(i=0;i&lt;4;i++) {
        draw_background_part(background2,16,24,8,8,(global.player_spawner[i] mod 16) *8,(global.player_spawner[i] div 16)*8)
        draw_text_colour((global.player_spawner[i] mod 16) *8,(global.player_spawner[i] div 16)*8,i+1,p_cyan,p_cyan,p_cyan,p_cyan,1)
        }
      
    if global.wrapping_timer mod 32 &lt; 16
        {
        draw_sprite(tank_mask,0,_x*8,_y*8);
        }    
        
        if palette_shift &gt; 0
    for(i=0;i&lt;tile_list_size;i++)
        {                    
        draw_background_part(background2,tile_x[i],tile_y[i],8,8,
        -12                        +dsin(180*(i+0.5)/tile_list_size)*palette_shift*50,
        -4+64 -dcos(180*(i+0.5)/tile_list_size)*palette_shift*50);
        }
   
    draw_background_part(background2,_tx,_ty,8,8,mouse_x,mouse_y)
    draw_background_part(background2,_tx,_ty,8,8,-12,60);   
}
else if mode = mode_palette {
    draw_background_tiled(background4,0,0);
    draw_set_halign(fa_left)draw_set_valign(fa_middle)draw_set_font(global.fontNormal)
    for(i=0;i&lt;tile_list_size;i++)
        {                    
        draw_background_part(background2,tile_x[i],tile_y[i],8,8,
        -12                        +dsin(180*(i+0.5)/tile_list_size)*palette_shift*50,
        -4+64 -dcos(180*(i+0.5)/tile_list_size)*palette_shift*50);
        }
    
    draw_text_colour(
        dsin(180*(selected+0.5)/tile_list_size)*palette_shift*50,
        64-dcos(180*(selected+0.5)/tile_list_size)*palette_shift*50,
        tile_name[tile_placer]
    ,p_white,p_white,p_white,p_white,1)        
    draw_background_part(background2,_tx,_ty,8,8,mouse_x,mouse_y)
    draw_background_part(background2,_tx,_ty,8,8, -12 , -4 + view_yview+72);               
}
else if mode = mode_settings {

    k = trif(select_pressed[mode]&gt;=0,select_pressed[mode],select[mode])
    c = trif(select_pressed[mode]&gt;=0 and select[mode]==select_pressed[mode],p_cyan,p_yellow)
    
//    draw_background_tiled(background4,0,0);
    draw_rectangle_colour(-16,-8,160,144,p_black,p_black,p_black,p_black,0);
    draw_background_part(background2,32,24,8,8,132,60)
    draw_set_halign(fa_left)draw_set_valign(fa_top)draw_set_font(global.fontNormal);
    
    draw_text_shadow(8, 0,  'LEVEL  NO.'+string(global.Round+1),trif(k==0,c,p_white));
    draw_text_shadow(8, 16, 'TANKS',trif(k==1,c,p_white));

     draw_background_part(background2,0,32,8,8,-8+(tank_selected_a mod 10)*10,28+(tank_selected_a div 10)*10);
     draw_background_part(background2,8,32,8,8,97+(tank_selected_b div 2) *10,28+(tank_selected_b mod 2)*10);

     _t = ds_list_size(global.tankSet);
     _x = _t div 10; 
     
    for(j=0;j&lt;_x;j++) {    
        _y = min(10,_t - j*10);
        for(i=0;i&lt;_y;i++) {
        t = trif(global.tankSet[|i+j*10] == undefined,0,global.tankSet[|i+j*10]);
        if (t&amp;1 == 0)
            draw_sprite(spr_enemytank,t,-4+i*10,32+10*j)
        }   
    }
        for(i=0;i&lt;4;i++) {  
        draw_sprite(spr_enemytank,i*2,-4+(10.5+i)*10,32)
    }
    
    pal_swap_set(palette_tank,4,false);
    for(j=0;j&lt;_x;j++) {    
        _y = min(10,_t - j*10);
        for(i=0;i&lt;_y;i++) {
        t = trif(global.tankSet[|i+j*10] == undefined,0,global.tankSet[|i+j*10]);
        if (t&amp;1 == 1)
            draw_sprite(spr_enemytank,t,-4+i*10,-8+8+32+10*j)
        }   
    }
        for(i=0;i&lt;4;i++) {    
        draw_sprite(spr_enemytank,i*2,-4+(10.5+i)*10,32+10)
    }
    pal_swap_reset(); 

    draw_text_shadow(8, +56,'SAVE',trif(k==2,c,p_white));
    draw_text_shadow(8, +56+16,'LOAD',trif(level_exists[global.Round],trif(k==3,c,p_white),p_dkgray));    
    draw_text_shadow(8, +56+32,'PLAY',trif(k==4,c,p_white));        
    draw_text_shadow(8, +56+48,'BACK',trif(k==5,c,p_white));     
    draw_text_shadow(8, +56+64,'EXIT',trif(k==6,c,p_white));  
              
} else if mode = mode_selectlevel {

    k = trif(select_pressed[mode]&gt;=0,select_pressed[mode],select[mode])
    c = trif(select_pressed[mode]&gt;=0 and select[mode]==select_pressed[mode],p_cyan,p_yellow)

    draw_rectangle_colour(-16,-8,160,144,p_black,p_black,p_black,p_black,0);
    
    draw_text_shadow(8, -8 + 8,'LEVEL SELECT',p_white);
    for(i=0;i&lt;5;i++)
     for(j=0;j&lt;5;j++) {
     _c = trif(level_exists[i*5+j],p_white,p_dkgray);
     
      draw_text_shadow(i*24,32+j*16,i*5+j+1,
        trif(global.Round==(i*5+j)&amp;&amp;global.wrapping_timer mod 32 &lt; 16,p_cyan,
         trif(k==(i*5+j+1),c,_c)))
         };

} else if mode = mode_confirmsave {

    k = trif(select_pressed[mode]&gt;=0,select_pressed[mode],select[mode])
    c = trif(select_pressed[mode]&gt;=0 and select[mode]==select_pressed[mode],p_cyan,p_yellow)

    draw_rectangle_colour(-16,-8,160,144,p_black,p_black,p_black,p_black,0);
    
    draw_text_shadow(8, 0,'SAVE',p_white);
    draw_text_shadow(-8, 16,'OVERWRITE THIS#STAGE?',p_white);
    draw_text_shadow(8, 64,'YES',trif(k==0,c,p_white));
    draw_text_shadow(64, 64,'NO',trif(k==1,c,p_white));
} else if mode = mode_confirmload {

    k = trif(select_pressed[mode]&gt;=0,select_pressed[mode],select[mode])
    c = trif(select_pressed[mode]&gt;=0 and select[mode]==select_pressed[mode],p_cyan,p_yellow)

    draw_rectangle_colour(-16,-8,160,144,p_black,p_black,p_black,p_black,0);
    
    draw_text_shadow(8, 0,'LOAD',p_white);
    draw_text_shadow(-8, 16,'LOADING THIS STAGE#WILL OVERWRITE#YOUR CURRENT STAGE##LOAD ANYWAY?',p_white);
    draw_text_shadow(8, 64,'YES',trif(k==0,c,p_white));
    draw_text_shadow(64, 64,'NO',trif(k==1,c,p_white));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="115">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>p = get_open_filename('Microtanks Level|*.mtl','');

if p != ""
{
    k = buffer_load(p);
    levelLoadFromBuffer(k);
    buffer_delete(k);
    
    instance_destroy(obj_tankspawner);
    instance_destroy(obj_defensetarget);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="114">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>p = get_save_filename('Microtanks Level|*.mtl','');

if p != ""
{
    k = levelSaveIntoBuffer();
    buffer_save(k,p);
    buffer_delete(k);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
